//@version=5
strategy("PhiloStone", overlay=true, margin_long=20, margin_short=20)

// Input parameters
maType = input.string(title="Select Kalman MA Type", options=["SMA", "EMA", "TMA"], defval="TMA")
maLength = input.int(title="MA Length", defval=66)
lengthKalman = input.int(12, "Length Kalman", minval=1)
stopLossPct = input.float(1, title="Stop Loss (%)", minval=0.01) / 100
lookbackPeriod = input.int(30, title="Divergence Lookback Period", minval=1)

// SMMA function
smma(src, length) =>
    var float result = na
    if na(result)
        result := ta.sma(src, length)
    else
        result := (result * (length - 1) + src) / length
    result

// SMMA calculations
smma33Low = smma(low, 33)
smma33High = smma(high, 33)
smma144Low = smma(low, 144)
smma144High = smma(high, 144)

// Kalman MA calculation
calculateMA(type, source, length) =>
    if type == "SMA"
        ta.sma(source, length)
    else if type == "EMA"
        ta.ema(source, length)
    else
        ta.sma(ta.sma(source, length), length) // TMA calculation

KalmanMA = calculateMA(maType, close, maLength)
var float klmf = na

calcKalmanFilter(source, length) =>
    float value1 = na
    float value2 = na
    value1 := 0.2 * (source - source[1]) + 0.8 * nz(value1[1])
    value2 := 0.1 * (high - low) + 0.8 * nz(value2[1])
    float lambda = math.abs(value1 / value2)
    float alpha = (-math.pow(lambda, 2) + math.sqrt(math.pow(lambda, 4) + 16 * math.pow(lambda, 2))) / 8
    // Use the previous value of klmf for the calculation
    alpha * source + (1 - alpha) * nz(klmf)

// Update klmf using the function's output in the main script body
klmf := calcKalmanFilter(close, lengthKalman)

//----------- Trading signals
buySignal = ta.crossover(klmf, KalmanMA)
sellSignal = ta.crossunder(klmf, KalmanMA)

// Strategy execution
// if buySignal
//     strategy.entry("Long", strategy.long)

// if sellSignal
//     strategy.entry("Short", strategy.short)

// Plotting
plot(KalmanMA, "Kalman MA", color.rgb(79, 75, 136))
plot(klmf, "KLMF", color.rgb(124, 95, 129))
plot(smma33Low, "SMMA 33 Low", color.rgb(0, 140, 255))
plot(smma33High, "SMMA 33 High", color.rgb(0, 140, 255))
plot(smma144Low, "SMMA 144 Low", color.rgb(255, 81, 0))
plot(smma144High, "SMMA 144 High", color.rgb(255, 81, 0))

// Plotting KalmanMA and klmf
plotKalmanMA = plot(KalmanMA, "Kalman MA", color=color.rgb(79, 75, 136))
plotKlmf = plot(klmf, "KLMF", color=color.rgb(124, 95, 129))

// Use plot identifiers in the fill function
fillColor = klmf > KalmanMA ? color.rgb(235, 228, 158, 30) : color.rgb(240, 172, 172, 30)
fill(plot1=plotKalmanMA, plot2=plotKlmf, color=fillColor)

// Accumulation/Distribution
// Calculate A/D
ad = ta.cum(close==high and close==low or high==low ? 0 : ((2 * close - low - high) / (high - low)) * volume)

// Lookback period
lookback = 100

// Function to find higher highs
higherHighs(series) =>
    ta.highest(series, lookback)[1] < series and series > series[1]

// Function to find lower highs in A/D
lowerHighAD(series) =>
    ta.highest(series, lookback)[1] > series and series < series[1]

// Function to find lower lows
lowerLows(series) =>
    ta.lowest(series, lookback)[1] > series and series < series[1]

// Function to find higher lows in A/D
higherLowAD(series) =>
    ta.lowest(series, lookback)[1] < series and series > series[1]

// Find divergences
priceHH = higherHighs(high)
adLH = lowerHighAD(ad)
priceLL = lowerLows(low)
adHL = higherLowAD(ad)

// Plotting lines for bullish divergences
var line bullishDivergenceLine = na
if priceHH and adLH
    if na(bullishDivergenceLine)
        bullishDivergenceLine := line.new(x1=bar_index[1], y1=high[1], x2=bar_index, y2=high, width=2, color=color.purple)
    else
        line.set_xy1(bullishDivergenceLine, x=bar_index[1], y=high[1])
        line.set_xy2(bullishDivergenceLine, x=bar_index, y=high)
else
    bullishDivergenceLine := na

// Plotting lines for bearish divergences
var line bearishDivergenceLine = na
if priceLL and adHL
    if na(bearishDivergenceLine)
        bearishDivergenceLine := line.new(x1=bar_index[1], y1=low[1], x2=bar_index, y2=low, width=2, color=color.purple)
    else
        line.set_xy1(bearishDivergenceLine, x=bar_index[1], y=low[1])
        line.set_xy2(bearishDivergenceLine, x=bar_index, y=low)
else
    bearishDivergenceLine := na

////RSI INDICATOR DIVERGENCE
// Get user input
int i_MaxDistance       = input.int(title="Max Bar Distance", defval=50)
int i_RSI_Length        = input.int(title="RSI Length", defval=14, minval=1)
float i_RSI_Overbought  = input.float(title="RSI Overbought", defval=71.0)
float i_RSI_Oversold    = input.float(title="RSI Oversold", defval=29.0)

// Get RSI value
rsiValue = ta.rsi(close, i_RSI_Length)

// --------- BULLISH DIVERGENCE --------- //
var float checkFirstLow     = na
var float initialLowPrice   = na
var float initialLowRSI     = na
var int initialLowIndex     = na
float swingLowRSI           = ta.lowest(rsiValue, 5)

// Detecting and storing the lowest low during oversold conditions
if rsiValue < i_RSI_Oversold
    if na(checkFirstLow) or low < checkFirstLow
        checkFirstLow := low
        initialLowIndex := bar_index
        initialLowRSI := rsiValue
else
    if not na(checkFirstLow)
        initialLowPrice := checkFirstLow
        checkFirstLow := na

// Function to check for divergence and draw lines
checkDivergence(lowPrice, lowIndex, lowRSI) =>
    if initialLowIndex != bar_index[1]
        if lowPrice[1] < initialLowPrice and lowPrice > lowPrice[1] and lowRSI > initialLowRSI and bar_index - initialLowIndex <= i_MaxDistance
            line.new(x1=initialLowIndex, y1=initialLowPrice, x2=bar_index[1], y2=lowPrice[1], color=color.lime, width=2)

// Check for divergence on every bar
if not na(initialLowPrice)
    checkDivergence(low, bar_index, rsiValue)


// --------- BEARISH DIVERGENCE --------- //
var float checkFirstHigh    = na
var float initialHighPrice  = na
var float initialHighRSI    = na
var int initialHighIndex    = na
float swingHighRSI          = ta.highest(rsiValue, 5)

if rsiValue > i_RSI_Overbought
    if na(checkFirstHigh) or high > checkFirstHigh
        checkFirstHigh := high
        initialHighIndex := bar_index
        initialHighRSI := rsiValue
else
    if not na(checkFirstHigh)
        initialHighPrice := checkFirstHigh
        checkFirstHigh := na

// Function to check for divergence and draw lines
checkDivergenceBear(highPrice, highIndex, highRSI) =>
    if initialHighIndex != bar_index[1]
        if highPrice[1] > initialHighPrice and highPrice < highPrice[1] and highRSI < initialHighRSI and bar_index - initialHighIndex <= i_MaxDistance
            line.new(x1=initialHighIndex, y1=initialHighPrice, x2=bar_index[1], y2=highPrice[1], color=color.lime, width=2)

// Check for divergence on every bar
if not na(initialHighPrice)
    checkDivergenceBear(high, bar_index, rsiValue)